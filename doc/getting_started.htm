<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Execution Monitor</title>
</head>

<body bgcolor="#808080" text="#000000" link="#336699" vlink="#3F7EBE" alink="#699BCD">

   <div align="center">
     <center>

  <table border="2" cellpadding="13" bordercolor="#CDCDCD" width="80%" id="AutoNumber1" cellspacing="3" style="border-collapse: collapse">
    <tr>
      <td width="100%" align="left" valign="TOP" bgcolor="#f0f0f0" border="0" >

<a name="TOP"><img border="0" src="../../../c++boost.gif" width="277" height="86"></a><br clear=left>

<h1 align="center">Getting started to use unit test framework</h1>

<p>Today is a momentous day. Today I am going to start a new life. I am going to stop
eating a greasy food, start attending a fitness club and ... since today I am going to  test programs 
I am writing. I can start after the last line of a program is completed or, even 
better idea, I can write tests while I am coding. And maybe next time I will 
write tests before the coding during the design stage. I have read a lot of literature
on how to write the tests, I have the unit test framework in hand and an idea of new
class. So let's get started.&nbsp;</p>
<p>Let say I want to encapsulate an unchangeable C character buffer with a length
into the simple class <b>const_string</b>. Rationale: a string class that does not
allocate a memory and provide a convenient read-only access to the preallocated
character buffer. I will probably want <b>const_string</b> to have an interface similar to 
the class <b>std::string</b>. What will I do  first? In my
new life I will start with writing a test module for future class <b>const_string</b>. It will look
like this:</p>
<p>const_string_test.cpp:</p>
<p>#include &lt;boost/test/unit_test.hpp&gt;<i><br>
using namespace</i> boost::unit_test_framework;</p>
<p>test_suite*<br>
init_unit_test_suite( <i>int</i> argc, <i>char</i>* argv[] )<br>
{&nbsp;<br>
&nbsp;&nbsp;&nbsp; test_suite* test= BOOST_TEST_SUITE(&quot;const_string
test&quot;);</p>
<p>&nbsp;&nbsp;&nbsp; return test;<br>
}</p>
<p>// EOF</p>
<p>Now I can compile it and link with the unit test framework. Done! I have a 
working test program. It is empty, so when I
run the program it produces following output:</p>
<p>Running 0 test case...<br>
*** No errors detected</p>
<p>Well, now it could be a good time to start a work on <b>const_string</b>.
First thing I imagine would be good to have is a constructors and trivial access
methods. So my class initial version looks like this:</p>
<p>const_string.hpp</p>
<p><i>class</i> const_string {<br>
<i>public</i>:<br>
&nbsp;&nbsp;&nbsp; // Constructors<br>
&nbsp;&nbsp;&nbsp; const_string();<br>
&nbsp;&nbsp;&nbsp; const_string( std::string <i>const</i>&amp; s )<br>
&nbsp;&nbsp;&nbsp; const_string( <i>char const</i>* s );<br>
&nbsp;&nbsp;&nbsp; const_string( <i>char const</i>* s, <i>size_t</i> length );<br>
&nbsp;&nbsp;&nbsp; const_string( <i>char const</i>* begin, <i>char const</i>*
end );</p>
<p>&nbsp;&nbsp;&nbsp; // Access methods<br>
&nbsp;&nbsp;&nbsp; <i>char const</i>* data() <i>const</i>;<br>
&nbsp;&nbsp;&nbsp; <i>size_t</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
length() <i>const;</i><br>
&nbsp;&nbsp;&nbsp; <i>bool</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
is_empty() <i>const</i>;</p>
<p>&nbsp;&nbsp;&nbsp; ...<br>
};</p>
<p>Now I am able to write a first test case - constructors testing - and add it
to a test suite. My test program became to look like this:</p>
<p>const_string_test.cpp:</p>
<p>#include &lt;boost/test/unit_test.hpp&gt;<i><br>
using namespace</i> boost::unit_test_framework;</p>
<p><i>void</i> constructors_test()<br>
{&nbsp;<br>
&nbsp;&nbsp;&nbsp; <b>const_string</b> cs0( &quot;&quot;
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 1 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs0.length(), (size_t)0 );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK( cs0.is_empty() );</p>
<p>&nbsp;&nbsp;&nbsp; <b>const_string</b> cs01( NULL
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 2 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs01.length(), (size_t)0 );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK( cs01.is_empty() );</p>
<p>&nbsp;&nbsp;&nbsp; <b>const_string</b> cs1( &quot;test_string&quot;
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 3 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( std::strcmp( cs1.data(),
&quot;test_string&quot; ), 0 );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs1.length(),
std::strlen(&quot;test_string&quot;) );</p>
<p>&nbsp;&nbsp;&nbsp; std::string s( &quot;test_string&quot;
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 4 //<br>
&nbsp;&nbsp;&nbsp; <b>const_string</b> cs2( s );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( std::strcmp( cs2.data(),
&quot;test_string&quot; ), 0 );</p>
<p>&nbsp;&nbsp;&nbsp; <b>const_string</b> cs3( cs1
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 5 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( std::strcmp( cs1.data(),
&quot;test_string&quot; ), 0 );</p>
<p>&nbsp;&nbsp;&nbsp; <b>const_string</b> cs4( &quot;test_string&quot;, 4
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 6 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( std::strncmp( cs4.data(),
&quot;test&quot;, cs4.length() ), 0 );</p>
<p>&nbsp;&nbsp;&nbsp; <b>const_string</b> cs5( s.data(), s.data() + s.length()
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 7 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( std::strncmp( cs5.data(),
&quot;test_string&quot;, cs5.length() ), 0 );</p>
<p>&nbsp;&nbsp;&nbsp; <b>const_string</b> cs_array[] = { &quot;str1&quot;,
&quot;str2&quot;
};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 8 //</p>
<p>&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs_array[0], &quot;str1&quot; );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs_array[1], &quot;str2&quot; );<br>
}</p>
<p>test_suite*<br>
init_unit_test_suite( <i>int</i> argc, <i>char</i>* argv[] )<br>
{&nbsp;<br>
&nbsp;&nbsp;&nbsp; test_suite* test= BOOST_TEST_SUITE(&quot;const_string
test&quot;);</p>
<p>&nbsp;&nbsp;&nbsp; test-&gt;add( BOOST_TEST_CASE( &amp;constructors_test ) );</p>
<p>&nbsp;&nbsp;&nbsp; <i>return</i> test;<br>
}</p>
<p>// EOF</p>
<p>The constructors_test test case is intended to check a simple feature of the class <b>const_string</b>:
an ability to construct itself properly based on different arguments. To test this
feature I am using such characteristics of constructed object as a data it
contains and a length. The specification of the class <b>const_string</b> does not contain any
expected failures, so, though the constructor can fail if I would pass a pointer to
an invalid memory,  error check control is not performed (can't require what was not
promised :-)). But for any valid input it should work. So I am trying to check
a construction for an empty string (1), a NULL string (2) a&nbsp; regular C string(3), 
an STL
string(4), a copy construction(5) and so on . Well, after fixing all the errors in
the implementation (do you write programs without errors from scratch?) I am able to pass
this test case and the unit test framework gives me the following report:</p>
<p>Running 1 test case...<br>
*** No errors detected</p>
<p>Encouraged I am moving on and adding more access methods:</p>
<p>const_string.hpp</p>
<p><i>class</i> const_string {<br>
<i>public</i>:<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; <i>char</i> operator[]( <i>size_t</i> index ) <i>const</i>;<br>
&nbsp;&nbsp;&nbsp; <i>char</i> at( <i>size_t</i> index ) <i>const</i>;<br>
&nbsp;&nbsp;&nbsp; ...<br>
};</p>
<p>I added the new feature - I need a new test case to check it. As a
result my test suite became to look like this:</p>
<p>const_string_test.cpp:</p>
<p>#include &lt;boost/test/unit_test.hpp&gt;<i><br>
using namespace</i> boost::unit_test_framework;</p>
<p><i>void</i> constructors_test()<br>
{<br>
&nbsp;&nbsp;&nbsp; ...&nbsp;<br>
}</p>
<p><i>void</i> data_access_test()<br>
{&nbsp;<br>
&nbsp;&nbsp;&nbsp; <b>const_string</b> cs1( &quot;test_string&quot; );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs1[(size_t)0], 't'
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 1 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs1[(size_t)4], '_' );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs1[cs1.length()-1], 'g' );</p>
<p>&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs1[(size_t)0], cs1.at( 0 )
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 2 //<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs1[(size_t)2], cs1.at( 5 ) );<br>
&nbsp;&nbsp;&nbsp; BOOST_CHECK_EQUAL( cs1.at( cs1.length() - 1 ), 'g' );</p>
<p>&nbsp;&nbsp;&nbsp; BOOST_CHECK_THROW( cs1.at( cs1.length() ),
std::out_of_range );&nbsp; // 3 //<br>
}</p>
<p>test_suite*<br>
init_unit_test_suite( <i>int</i> argc, <i>char</i>* argv[] )<br>
{&nbsp;<br>
&nbsp;&nbsp;&nbsp; test_suite* test= BOOST_TEST_SUITE(&quot;const_string
test&quot;);</p>
<p>&nbsp;&nbsp;&nbsp; test-&gt;add( BOOST_TEST_CASE( &amp;constructors_test ) );<br>
&nbsp;&nbsp;&nbsp; test-&gt;add( BOOST_TEST_CASE( &amp;data_access_test ) );</p>
<p>&nbsp;&nbsp;&nbsp; <i>return</i> test;<br>
}</p>
<p>// EOF</p>
<p>In the data_access_test test case I am trying to check the class <b>const_string</b> character access
correctness. While tests (1) checks valid access using <b>const_string</b>::operator[] and test (2)
checks valid access using method <b>const_string</b>::at(), there is one more thing to test. The
specification of the method <b>const_string</b>::at() contains validation for the out of bound access. That
was test (3) is intended to do: check that the validation is working. A testing of
a validation and error handling code is an important part of a unit testing and should
not be left for a production stage. The data_access_test test case passed and I am ready for the next
step.&nbsp;&nbsp;</p>
<p>Continuing my effort I am able to complete class <b>const_string</b> (see <a href="getting_started/const_string.hpp">Listing
1</a>) and testing module for it (see <a href="getting_started/const_string_test.cpp">Listing
2</a>) that is checking all features that are presented in the class <b>const_string</b>
specification.&nbsp;&nbsp;</p>
<p>Your testing habits could be a little different. You could start with a class/library development and then at some point start writing test cases on
feature basis. Or you can, given a detailed specification for the future product,
including expected interfaces, immediately start with writing all test cases (or
it could be a different person, while you working on implementation at the same
time). In any case you should not have any problems to use facilities provided
by the unit test framework and, let me hope, be able to write a stable,
bulletproof code. And what is even more important is your confidence in an
ability to make a changes of any complexity without involving a lengthy regression
testing of your whole product. Your test module and the unit test framework will
stay behind your back to help you with any occasional errors.</p>
<hr>
<p>© <a href="mailto:boost_test_library@consultant.com">Gennadiy Rozental</a> 2001</p>
<p>Revised: 
<!--webbot bot="Timestamp" S-Type="EDITED"
S-Format="%d %B, %Y" startspan -->24 December, 2001<!--webbot bot="Timestamp" endspan i-checksum="38511" -->
</p></TR>
</table>
</body>