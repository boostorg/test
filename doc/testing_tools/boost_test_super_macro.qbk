[/
 / Copyright (c) 2015 Raffi Enficiaud
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:boost_test_super_macro `BOOST_TEST` or the Swiss Army knife]

Once a test case has been declared, the body of this test should be written. A test case is a 
sequence of operations in which *assertions* are inserted. Those assertions run /statements/ that verify the integrity 
of the pre and post conditions of the operations. There are three kind of assertions, having different meaning on the
consistency of the test case:

* requirements: this is the strongest level of the assertions. The test case execution stops if the statement in the assertion fails. This
  type of assertions should be used when the reminder of the test-case relies heavily on this requirement (example: an object 
  allocated on the heap is tested, but the factory returns `NULL`). 
* basic checks: this is the most commonly used assertion level. If the statements evaluates to `false`, the test case is 
  flagged as failed but its execution continues. 
* warnings: this is the lowest level of the assertions. The test case execution continues and a warning message is logged. 
  The warning does not change the success status of a test case.
  
These three levels of assertions are reported into the test log and test output, as described in details in the 
[link boost_test.users_guide.testing_tools.tools_assertion_severity_level severity levels] section. The granularity of the
report depends on the current [link boost_test.users_guide.runtime_config.rt_param_reference.param_log_level log level] and 
[link boost_test.users_guide.runtime_config.rt_param_reference.param_report_level report level].

A unique interface is given by the variants of the `BOOST_TEST` assertion:

* `BOOST_TEST_REQUIRE`
* `BOOST_TEST_CHECK` or just `BOOST_TEST`
* `BOOST_TEST_WARN`

As their name suggests, these assertions are, in order, for /requirement/, /checks/ and /warnings/.

[warning To get all the functionalities of `BOOST_TEST` family of assertions, a C++11 capable compiler is required, especially
 supporting the `auto` and `decltype` keywords and the variadic macros. The documentation focuses on these set of compilers. A 
 limited support is provided for C++03 compilers.]

[section Acceptable expressions]

The __BOOST_TEST__ assertion uses some tricks with C++ operator overloading in order to perform its magic. This is why some expressions 
are in fact not possible, such as:

* ternary operations
* coumpound statements containing more than one sequence point
* statements containing comas,


[section Collection comparison]

[endsect] [/ collections]

[endsect] [/ acceptable expressions]

[section Options to `BOOST_TEST`]

The __BOOST_TEST__ assertion can be enriched with more control about the test or the diagnostic. In particular:

* an optional message, printed in case of failure, can be added. 
* tags can be added in order to have a more detailed diagnostic. Currently only the bitwise comparison tag is available
* floating point tolerances can be controlled


[section Optional failure message]

When an assertion fails, a message is logged containing:

* the body of the statement that failed
* the name of the file and the line of the failed assertion
* the name of the test case containing this assertion

The purpose of all these information is to isolate as quickly as possible the test that failed from the others. The *feedback*
that the execution of the test case provides is an important cue, for the following reasons:

* within the scheme of a continuous build/test, the logs available from the server contain this information, which points to
  a particular statement in the code
* the *cost* for reproducing an error is induced by the following steps:
  
  * identify the test module that failed in case there are many
  * compile and run the test module to reproduce the error
  * identify the line of the code that failed, 
  * fix the test directly if all these informations are enough, or start a debug session 

We can see from the scheme above that reproduction of an error is /costly/, since usually one tends to reproduce the error,
which in turn induces at least the compilation of the test module. Also, a hidden cost is the lookup at the line of code
that contains the failing statement, which triggers a sequence of back and forth lookup between the log on one hand and the code
on the other hand.

The information extracted from the logs suggests the following fact: 

[tip Richness of the information contained in the logs is a key for the rapid understanding and the resolution of a failed statement]

While perfectly exact and precise, the file name, test case name, line number of a failed statement carries an information that 
is partial with regards to the meaning of the failed statement. 
Sometimes these information are not informative enough.

[endsect] [/ message]





[section Bitwise comparison]

[caution this feature is not available for non C++11 compilers (the extended diagnostic is disabled).]

The tag [classref boost::test_tools::bitwise] can be provided to the __BOOST_TEST__ macro in order to have an extended bitwise comparison
of the operands. 

The predicate used for comparison ([funcref boost::test_tools::tt_detail::bitwise_compare `bitwise_compare`]) gives extended information
on the locations where the two operands do not match. 

```
BOOST_AUTOR_TEST_CASE(test)
{
  namespace tt = boost::test_tools;
  int a = 0xAB;
  int b = 0x88;
  BOOST_TEST( a == b, tt::bitwise() );
}
```

[endsect] [/ bit sequences]



[section Comparing floating points]

[tip Consider using [link boost_test.users_guide.tests_organization.decorators decorators] 
  for setting the tolerance of the comparisons
]

```
BOOST_AUTOR_TEST_CASE(test)
{
  namespace tt = boost::test_tools;
  double d1 = 1.1e-5;
  double d2 = 1.101e-5;
  BOOST_TEST( d1 == d2, tt::tolerance( 1e-7 ) );
}
```


[endsect] [/ floating points]


[endsect] [/ options to boost_test]

[endsect] [/ boost_test_super_macro]
